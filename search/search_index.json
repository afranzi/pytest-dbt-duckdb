{"config":{"lang":["en"],"separator":"[\\s\\u200b\\-_,:!=\\[\\]()\"`/]+|\\.(?!\\d)|&[lg]t;|(?!\\b)(?=[A-Z][a-z])","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"PyTest dbt Duckdb","text":"<p>Fearless testing for dbt models, powered by DuckDB .</p> <p>What is this?</p> <p>pytest-dbt-duckdb is an open-source testing framework that allows you to validate dbt models end-to-end, using DuckDB as an in-memory execution engine. Designed for speed, portability, and CI/CD automation, it enables you to test dbt transformations before deployment, ensuring trust in your data.</p>"},{"location":"#why-this-exists","title":"Why This Exists","text":"<p>Assumptions are dangerous.</p> <p>An untested model is a ticking time bomb\u2014silent, unseen, but waiting to fail at the worst possible moment. This library ensures your transformations, dependencies, and outputs are battle-tested before deployment.</p>"},{"location":"#data-must-be-tested-not-trusted","title":"Data must be tested, not trusted.","text":"<p>Modern analytics teams move fast\u2014but in their race to ship, they often skip a crucial step: rigorous testing. A broken transformation can mean misreported revenue, misleading product insights, or silent failures that creep into dashboards.</p> <p>\"Each dbt model untested is a story unfinished.\"</p> <p>Here, in the shadows of SQL models and YAML configurations, we forge a guardian\u2014a pytest plugin that ensures every dbt model is battle-tested, validated, and ready before it touches production.</p> <p>With DuckDB as the testing engine, you can:</p> <ul> <li> Define test cases with simple YAML scenarios.</li> <li> Execute them in DuckDB, locally and instantly\u2014no warehouse needed.</li> <li> Integrate with CI/CD pipelines, catching errors before deployment.</li> <li> Extend with custom DuckDB functions for specialized assertions.</li> </ul> <p>Data must be tested, not trusted. Let\u2019s test fearlessly.</p> DBT E2E Test Flow"},{"location":"#who-is-this-for","title":"Who is this for?","text":"<p>Whether you are a craftsman of data or a guardian of analytics, this library is your lantern in the dark, guiding you toward precision and reliability.</p> <ul> <li> Data Engineers \u2192 Validate dbt models before they reach production.</li> <li> Analytics Engineers \u2192 Ensure clean, tested data in dashboards.</li> <li> CI/CD Developers \u2192 Automate SQL testing in pull requests.</li> </ul>"},{"location":"#key-features","title":"Key Features","text":"Feature Description Fast Testing Runs entirely in DuckDB\u2014no warehouse costs. \ufe0f YAML-Based Tests Define test scenarios using declarative YAML. CI/CD Ready Seamless integration with GitHub Actions, Jenkins, GitLab CI/CD. Custom Functions Extend with user-defined DuckDB functions. Snapshot Testing Compare actual vs. expected outputs with precision."},{"location":"#how-it-works","title":"How It Works","text":"<p> See the Usage Section</p>"},{"location":"usage/","title":"Usage","text":"<p>This guide explains how to configure, define, and execute end-to-end tests for dbt models using pytest-dbt-duckdb.</p> <ul> <li> Define test scenarios in YAML</li> <li> Configure dbt with profiles.yml</li> <li> Run tests locally using DuckDB</li> <li> Integrate tests seamlessly into CI/CD pipelines</li> </ul>"},{"location":"usage/#project-configuration","title":"\ufe0f Project Configuration","text":""},{"location":"usage/#installation","title":"Installation","text":"<p>Step 1: Install package</p> <p>Install the package using pip:</p> <pre><code>pip install pytest-dbt-duckdb\n</code></pre> <p>Step 2: Create profiles.yml</p> <p>Configure dbt to use DuckDB as the testing engine by adding this to your profiles.yml file:</p> profiles.yml<pre><code>pytest:\n  target: duckdb\n  outputs:\n    duckdb:\n      type: duckdb\n      path: \"{{ env_var('DBT_DUCKDB_PATH') }}\"\n      database: \"{{ env_var('DBT_DUCKDB_DATABASE') }}\"\n      schema: \"dbt_pytest_gummy\"\n</code></pre> <p>Step 3: Define Environment Variables</p> <p>In order for dbt to work correctly, set the required environment variables in pytest.ini:</p> <pre><code>[tool.pytest.ini_options]\nminversion = \"7.0\"\naddopts = \"-p no:warnings\"\ntestpaths = [\"tests\"]\nenv = [\n    \"DBT_RAW_DATABASE = pyduck\",\n    \"DBT_DATABASE_NAME = pyduck\",\n    \"DBT_PROFILE = pytest\"\n]\n</code></pre>"},{"location":"usage/#writing-a-test-scenario","title":"Writing a Test Scenario","text":"<p>Structure of a YAML Test</p> <p>Each test follows this structure:</p> <ul> <li><code>id</code>: test unique identifier.</li> <li><code>given</code>: Input datasets (CSV/JSON files) to load.</li> <li><code>seed</code>: dbt seeds to be executed.</li> <li><code>build</code>: dbt models to be executed.</li> <li><code>then</code>: Expected outputs after transformation.</li> </ul>"},{"location":"usage/#test-case-example","title":"Test Case Example","text":"test_tasks.yaml<pre><code>tests:\n  - id: Validate full project\n    given:\n      - schema: netflix\n        table: shows\n        path: 'e2e/given/netflix_titles.csv'\n    seed: seed_show_ratings\n    build: '+int_show+'\n    then:\n      - schema: 'dbt_pytest_gummy'\n        table: 'fct_director'\n        path: 'e2e/then/fct_director.csv'\n      - schema: 'dbt_pytest_gummy'\n        table: 'fct_cast'\n        path: 'e2e/then/fct_cast.csv'\n</code></pre>"},{"location":"usage/#running-the-tests","title":"Running the Tests","text":"test_dbt.py<pre><code>import pytest\nfrom pytest_dbt_duckdb.plugin import DuckFixture, TestFixture, load_yaml_tests\n\nyaml_data = list(load_yaml_tests(\"tests/data\"))\n\n@pytest.mark.parametrize(\"fixture\", yaml_data, ids=[x.id for x in yaml_data])\ndef test_dbt_scenarios(fixture: TestFixture, duckdb_fixture: DuckFixture):\n    duckdb_fixture.execute_dbt(\n        nodes_to_load=fixture.given,\n        seed=fixture.seed,\n        build=fixture.build,\n        nodes_to_validate=fixture.then,\n        resources_folder=\"tests/data\",\n        dbt_project_dir=\".\",\n    )\n</code></pre>"},{"location":"usage/#hard-requirement-defining-dbt-data-types","title":"\ufe0f Hard Requirement: Defining dbt Data Types","text":"<p>Mandatory: Define Column Data Types</p> <p>For pytest-dbt-duckdb to function correctly, all models in the given and then sections must have explicitly defined dbt column data types.</p>"},{"location":"usage/#why-is-this-required","title":"Why is this Required?","text":"<p>Since the framework recreates models inside DuckDB, it needs accurate data type definitions to:</p> <ul> <li> Ensure proper table creation in DuckDB</li> <li> Prevent type mismatches between expected vs. actual results</li> <li> Avoid errors when populating test data</li> </ul> <p>How to Define Column Types in dbt Ensure that every model in given and then is properly defined in your dbt project under schema.yml:</p> schema.yml<pre><code>version: 2\nmodels:\n  - name: stg_show_rating\n    description: Map file with Rating System age &amp; audiences\n    columns:\n      - name: rating_id\n        description: Unique Rating Identifier\n        data_type: text\n        data_test:\n          - not_null\n          - unique\n      - name: rating_name\n        description: Readable Rating name\n        data_type: text\n      - name: only_adults\n        description: Flag to indicate if the show aims to be watched by only adults\n        data_type: boolean\n      - name: min_age\n        description: Suitable for people over this age\n        data_type: integer\n        data_tests:\n          - dbt_utils.accepted_range:\n              min_value: 2\n              max_value: 18\n              inclusive: true\n</code></pre>"},{"location":"usage/#what-happens-if-you-skip-this","title":"What Happens if You Skip This?","text":"<ul> <li> If column types are not defined, the framework cannot recreate and populate the test models inside DuckDB.</li> <li> This will result in test failures due to schema mismatches and incorrectly inferred types.</li> </ul> <p> Solution: Always define your dbt column types properly to ensure reliable testing.</p>"},{"location":"usage/#running-with-custom-duckdb-functions","title":"Running with Custom DuckDB Functions","text":"<p>Extending DuckDB with Custom Functions</p> <p>If you need to extend the DuckDB engine with additional functionality, you can define custom functions:</p> test_with_udfs.py<pre><code>from pytest_dbt_duckdb.connector import DuckFunction, ExtraFunctions\n\nextra_functions = ExtraFunctions(\n    functions=[\n        DuckFunction(name=\"tokenize\", function=tokenize, parameters=[str], return_type=list[str]),\n        DuckFunction(name=\"edit_distance\", function=edit_distance, parameters=[str, str, int], return_type=int),\n    ]\n)\n</code></pre> <p>Pass <code>extra_functions</code> to <code>execute_dbt</code> when running tests.</p>"},{"location":"usage/#explore-testing-examples","title":"Explore Testing Examples","text":"<p>Want to see pytest-dbt-duckdb in action? Check out our real test scenarios in the GitHub repository:  GitHub Repository - Testing Examples</p> <p>These examples include:</p> <ul> <li> Predefined YAML test cases</li> <li> Sample dbt projects</li> <li> Fully configured pytest setup</li> </ul> <p>Use them as a starting point for writing your own end-to-end dbt model tests!</p>"},{"location":"usage/#summary","title":"Summary","text":"<ul> <li>Define input data (given), models to build (build), and expected outputs (then).</li> <li>Configure dbt using profiles.yml and environment variables.</li> <li>Run tests locally with DuckDB for fast execution.</li> <li>Integrate tests with CI/CD pipelines to prevent regressions.</li> <li>Extend with custom DuckDB functions for advanced testing.</li> </ul>"}]}